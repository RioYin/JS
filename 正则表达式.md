<h1>正则表达式</h1>

* 相关符号

| 符号     |   描述  |
| :-----:  | :-----:|
| ·     | 除了回车符和换行符之外的所有字符[^\r\n] |
| \d    |  数字 [0-9] |
| \D    |  非数字[^0-9] |
| \s    |  空白符 [\t\v\f\r\n] |
| \S    |  非空白符 [^\t\v\f\r\n] |
| \w    |  单词字符，即字母、数字、下划线 [a-zA-Z0-9_] |
| \W    |  非单词字符[^a-zA-Z0-9_] |
| \b    |  单词边界 |
| \B    |  非单词边界 |
| \t    |  水平制表符 |
| \v    |  垂直制表符 |
| \n    |  换行符 |
| \r    |  回车符 |
| \0    |  空字符 |
| \f    |  换页符 |
| \cX    |  与X对应的控制字符（Ctrl+X） |
| ()    |  分组 |
| []    |  分类 |
| {}    |  循环多次，例如：{4}，共4次 |
| ^     |  开始；取反 |
| $     |  结束；取组 |
| ?     |  0次或1次 |
| +     |  至少1次 |
| *     |  任意次 |
| {n,m} |  n到m次，或者{n,}(至少n次)，或者{0,m}(最多m次) |
| ?:    |  忽略分组，例如：/(?:abc).(123)/，第一组为123 |
| ?=    |  是否符合，例如：/\w(?=\d)/，匹配'后面跟着数字'的'字符' |
| ?!    |  是否不符合，例如：/\w(?!\d)/，匹配'后面不跟着数字'的'字符' |
| g     |  全局匹配 |
| i     |  忽略大小写匹配 |
| m     |  多行匹配 |

* 相关属性及方法

| 属性或方法       |   描述  |
| :-----:         | :-----:|
| reg.source      | 正则表达式的文本字符串 |
| reg.lastIndex   | 当前表达式匹配内容的最后一个字符的下一个位置 |
| reg.test(str)   | 测试字符串参数中是否存在匹配正则表达式模式的字符串,返回true或false |
| reg.exec(str)   | 对字符串执行搜索,如果没有匹配的文本则返回null，有则返回一个结果数组 |
| str.search(reg) | 检索与正则表达式相匹配的字符串,返回第一个匹配结果的index，查找不到返回-1,不执行全局匹配，它将忽略/g，并且总是从字符串的开始进行检索 |
| str.match(reg)  | 检索与正则表达式相匹配的字符串,如果没有找到则返回null，有则返回一个数组 |
| str.split(reg)  | 使用正则表达式来将原字符串分割成字符数组  |
| str.replace(reg,function/newstr) | 将符合正则表达式的字符替换为新字符,function(match,group1...groupN,index,origin)中有四个参数，其中第二个参数随分组的数量而定  |

* 注：str.replace(reg,function)中的function会在每次匹配替换的时候调用，有四个参数 
  * 1.匹配字符串 (match)
  * 2.正则表达式分组内容，没有分组则没有改参数 (group1,group2……)
  * 3.匹配项在字符串中的index (index)
  * 4.原字符串 (origin)
* 举例：

```
"a1b2c3d4e5".replace(/(/d)(/w)(/d)/g,function(match,group1,group2,group3,index,origin){
    console.log(match);
    return group1+group3;
});
/*结果:  
"1b2"
"3d4"
"a12c34e5"
*/
```
